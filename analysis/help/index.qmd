---
title: HELP loan analysis
subtitle: Interrogating HELP debts in the ATO individual sample files
format:
  360-analysis-html:
    # override for selected charts that do not expose individuals
    output: false
author: James Goldie
date: last-modified
code-fold: true
---

```{r}
#| label: setup
library(tidyverse)
library(RColorBrewer)
library(here)
dir.create(here("out", "explore"), showWarnings = FALSE, recursive = TRUE)
```

# Unzipping the data

Data is delivered as a `.7z` file, `Sample files 2011-12 to 20??-20??.7z` (covering from 2011-12 onward).

:::{.callout-note}
The 1% sample files from 2003-04 to 2010-11 don't appear to have information on HELP debt, only an indicator showing _whether_ they have a debt.
:::

The file has individual, nested ZIP files for each financial year that have their own passwords.

:::{.callout-warning}
For now I'm going to manually unzip these password-protected ZIP files, so the following code will assume that the unprotected CSV files are available somewhere under `/data/raw` as `20??_sample_file.csv`.

**These files are not version controlled; you must apply for access to them from the [Australian Taxation Office](https://www.ato.gov.au/about-ato/research-and-statistics/in-detail/taxation-statistics/taxation-statistics-previous-editions/taxation-statistics-2017-18/statistics/individuals/individuals-sample-files).
:::

## Exploration

```{r}
#| label: load-data
tibble(
  path = list.files(
    here("data", "raw"),
    pattern = "20.._sample_file\\.(csv|txt)",
    recursive = TRUE,
    full.names = TRUE)) |>
  mutate(
    year_end = str_extract(basename(path), "20.."),
    data = map(path, read_csv,
      col_select = c(Taxable_Income, Help_debt))) ->
nested_2pc
```


```{r}
#| label: combine
nested_2pc |>
  pull(data) |>
  set_names(nested_2pc$year_end) |>
  bind_rows(.id = "year_end") |>
  select(year_end, income = Taxable_Income, help_debt = Help_debt) ->
unnested_2pc
```

Let's start exploring HELP debt and income with some histograms (well, frequency polygons):

```{r}
#| label: explore-histograms
#| output: true
# extend colour palette to > 9 years
pal_YlGnBu <- brewer.pal(7, "YlGnBu") |> colorRampPalette()
pal_YlOrRd <- brewer.pal(7, "YlOrRd") |> colorRampPalette()
year_count <- unnested_2pc |> pull(year_end) |> unique() |> length() 
help_balance_pal <- pal_YlGnBu(year_count)
income_pal <- pal_YlOrRd(year_count)

ggplot(unnested_2pc) +
  aes(x = help_debt) +
  geom_freqpoly(aes(colour = year_end)) +
  scale_x_continuous(
    transform = "log10",
    guide = guide_axis_logticks(),
    labels = scales::label_number(
      prefix = "$",
      scale_cut = scales::cut_short_scale())) +
  scale_colour_manual(values = help_balance_pal) +
  scale_y_continuous(
    labels = scales::label_number(scale_cut = scales::cut_short_scale())) +
  theme_minimal(base_size = 18) +
  theme(axis.ticks.length.x = rel(3)) +
  labs(
    x = "HELP debt balance",
    y = "Number of people",
    colour = "Financial\nyear end",
    title = "Distribution of HELP balances over time")

ggplot(unnested_2pc) +
  aes(x = income) +
  geom_freqpoly(aes(colour = year_end)) +
  scale_x_continuous(
    transform = "log10",
    guide = guide_axis_logticks(),
    labels = scales::label_number(
      prefix = "$",
      scale_cut = scales::cut_short_scale())) +
  scale_y_continuous(
    labels = scales::label_number(scale_cut = scales::cut_short_scale())) +
  scale_colour_manual(values = income_pal) +
  theme_minimal(base_size = 18) +
  theme(axis.ticks.length.x = rel(3)) +
  labs(
    x = "Taxable income",
    y = "Number of people",
    colour = "Financial\nyear end",
    title = "Distribution of taxable income over time")
```

How many people from each sample even have a debt?

```{r}
#| label: has-debt-percentage
#| output: true
unnested_2pc |>
  group_by(year_end, has_help_debt = help_debt > 0) |>
  summarise(n = n()) |>
  mutate(prop = n / sum(n, na.rm = TRUE)) |>
  filter(has_help_debt == TRUE)
```

And the mean income and balance each year (including those for whom it's zero)?

```{r}
#| label: mean-income-balance
#| output: true
unnested_2pc |>
  group_by(year_end) |>
  summarise(
    mean_income = mean(income, na.rm = TRUE),
    mean_help_bal = mean(help_debt, na.rm = TRUE)) |>
  ungroup()
```

### Estimating 2022, 2023 and 2024 using FY2001 taxpayers

Because we don't have sample files beyond 2021, I'm going to use that latest sample file for 2022, 2023 and 2024 to see the effect of indexation rate (marking those years with `*`).

:::{.callout-important}
The Australian Government has announced that HELP debts will now be indexed according to the lowest of the Wage Price index and the Consumer Price Index. This change will retroactively be applied from FY2023.

I'll investigate the effect of this policy with the years marked `+` (still using the FY2021 returns).
:::

```{r}
#| label: estimate-2022-2024
replace_year <- function(df, year) {
  df |> filter(year_end == "2021") |> mutate(year_end = year)
}

unnested_2pc |>
  bind_rows(
    unnested_2pc |> replace_year("2022*"),
    unnested_2pc |> replace_year("2023*"),
    unnested_2pc |> replace_year("2024*"),
    unnested_2pc |> replace_year("2023+"),
    unnested_2pc |> replace_year("2024+")) ->
unnested_estimated  
```

### Calculating indexation and mandatory repayment

The Parliamentary Library [keeps a historical record](https://www.aph.gov.au/About_Parliament/Parliamentary_Departments/Parliamentary_Library/pubs/rp/rp2021/Chronologies/HigherEducation#_Toc67381554) of HELP loan repayment rates. The ATO has [more recent tables](https://www.ato.gov.au/tax-rates-and-codes/study-and-training-support-loans-rates-and-repayment-thresholds).

:::{.callout-note}
These tables are saved in `/data`. You may need to re-retrieve them if you're reproducing this analysis in later years.
:::

:::{.callout-warning}
For this analysis, I'm simply using taxable income as the measure for repayment. In reality, a few other items are considered:

- plus net rental losses (from 1996)
- plus total reportable fringe benefits amounts (from 1999)
- deduct exempt foreign employment income (from 2005)
- plus any total investment loss (which includes net rental losses) (from 2009)
- plus reportable super contributions (from 2009)
:::

Let's tidy up the repayment rate tables. Note that the top rate for each year is a _starting threshold_, so we'll change those to be infinite:

```{r}
#| label: get-repayment-rates
here("data", "repayment-rates-2004-2019.csv") |>
  read_csv(col_types = "ccc") |>
  pivot_longer(-Year, names_to = "rate", values_to = "threshold") |>
  mutate(
    year_end = paste0("20", str_sub(Year, 6, 7)),
    rate = if_else(rate == "Nil", "0", rate),
    rate = rate |>
      parse_number(locale = locale(grouping_mark = " ")) |>
      (\(x) x / 100)(),
    threshold = parse_number(threshold,
      locale = locale(grouping_mark = " "))) |>
  select(year_end, rate, threshold) |>
  filter(!is.na(threshold)) ->
repayment_rates_oldest

here("data", "repayment-rates-2019-2021.csv") |>
  read_csv(col_types = "ccc") |>
  pivot_longer(-Rate, names_to = "Year", values_to = "threshold") |>
  mutate(
    year_end = paste0("20", str_sub(Year, 6, 7)),
    rate = if_else(Rate == "Nil", "0", Rate),
    rate = rate |>
      parse_number(locale = locale(grouping_mark = " ")) |>
      (\(x) x / 100)(),
    threshold = parse_number(threshold,
      locale = locale(grouping_mark = " "))) |>
  select(year_end, rate, threshold) |>
  filter(!is.na(threshold)) ->
repayment_rates_older

# FY2022-2024
tidy_ratetables <- function(path, suffix = c("*", "+")) {
  suffix <- match.arg(suffix)
  year <- paste0(str_extract(basename(path), "20.."), suffix)
  
  # read, turn thresholds into upper limits
  # (note differing kinds of hyphens in each table!)
  read_csv(path, col_types = "cc") |>
    mutate(
      year_end = year,
      threshold = `Repayment income (RI)` |>
        str_remove_all("\\$[\\d,]{1,9} \\p{Pd} ") |>
        str_replace_all(c(
          "Below " = "",
          " and above" = "")) |>
        parse_number(),
      # rate: nil => 0, drop %, / 100
      rate = if_else(`Repayment rate` == "Nil", "0", `Repayment rate`),
      rate = rate |>
        parse_number(locale = locale(grouping_mark = " ")) |>
        (\(x) x / 100)()) |>
    select(year_end, threshold, rate)
}

tibble(
  path = list.files(here("data"),
    pattern = glob2rx("repayment-rates-FY20??.csv"),
    full.names = TRUE)) ->
rate_table_files_newest

rate_table_files_newest |>
  mutate(data = map(path, tidy_ratetables)) |>
  unnest(data) |>
  select(-path) ->
repayment_rates_new

rate_table_files_newest |>
  filter(str_detect(path, regex("(23|24)"))) |>
  mutate(data = map(path, tidy_ratetables, suffix = "+")) |>
  unnest(data) |>
  select(-path) ->
repayment_rates_new_alppolicy
  

# combine the rates (set upper rates to inf)
repayment_rates_oldest |>
  bind_rows(repayment_rates_older) |>
  bind_rows(repayment_rates_new) |>
  bind_rows(repayment_rates_new_alppolicy) |>
  rename(repay_rate = rate, repay_threshold = threshold) |>
  group_by(year_end) |>
  mutate(repay_threshold =
    if_else(repay_rate == max(repay_rate, na.rm = TRUE), Inf, repay_threshold)) ->
repayment_rates
```

Now we can apply them to our individual sample to work out repayment obligations based on people's incomes.

Since repayments are not progressive, we can use a rolling join to identify the relevant threshold and rate:

```{r}
#| label: calculate-repayments
unnested_estimated |>
  left_join(repayment_rates, join_by(
    year_end == year_end,
    closest(income <= repay_threshold))) |>
  mutate(repay_amount = help_debt * repay_rate) ->
unnested_repayments
```

Now let's handle indexation. This one is a fixed rate of taxable income each year. The ATO has [a table of historical indexation rates](https://www.ato.gov.au/tax-rates-and-codes/study-and-training-support-loans-indexation-rates) going back to 2013 (not ideal, but until 2011, the Higher Education Operations Grant index was used).

:::{.callout-note}
Reporting of the Australian Government's announcement that HELP loans will retroactively follow the lower of CPI and WPI from FY2023 notes that last year's 7.1% indexation will be reduced to 3.2%.

This year's was expected to be 4.7% on the basis of the CPI, but the latest WPI isn't out yet (latest release is December, and the March quarter is released on May 15).

As of the December release, annual WPI had risen to 4.2%. I'm going to use that figure for now, but it looks like WPI has been trending up since the pandemic â€” it could be that that figure lands close to 4.7% and hardly moves at all.
:::

```{r}
#| label: indexation-rates
tribble(
  ~ year_end, ~ index_rate,
  "2024+",    0.042,
  "2023+",    0.032,
  "2024*",    0.047,
  "2023*",    0.071,
  "2022*",    0.039,
  "2021",     0.006,
  "2020",     0.018,
  "2019",     0.018,
  "2018",     0.019,
  "2017",     0.015,
  "2016",     0.015,
  "2015",     0.021,
  "2014",     0.026,
  "2013",     0.020) ->
indexation_rates
```

Let's do another rolling join to the tax returns. Then, once we have both repayment amount and indexation amount, we'll work out net change and divide it by the balance to work out number of years to repay (obviously this assumes no future change to thresholds or income):

```{r}
#| label: calculate-indexation
unnested_repayments |>
  left_join(indexation_rates, join_by(year_end == year_end)) |>
  mutate(index_amount = help_debt * index_rate) |>
  filter(!is.na(index_rate)) |>
  # calc net change and repayment time
  mutate(
    net_reduction = repay_amount - index_amount,
    payback_yrs = help_debt / net_reduction) ->
unnested_payback
```

### Visualise debt changes and payback periods

Let's try some visualisations to see this payback distribution. (We'll need to remove the people with no debt.) I'd particularly like to check assumptions of normality here:

```{r}
#| label: vis-payback
#| output: true
unnested_payback |>
  filter(help_debt > 0) |>
  mutate(
    repaying = payback_yrs > 0,
    payback_yrs_abs = abs(payback_yrs)) ->
finite_paybacks

# extend palette
pal_PuRd <- brewer.pal(7, "PuRd") |> colorRampPalette()
year_count_ext <- finite_paybacks |> pull(year_end) |> unique() |> length() 
payback_pal <- pal_PuRd(year_count_ext)

# payback period
ggplot(finite_paybacks |> filter(!str_ends(year_end, "[*+]"))) +
  aes(x = payback_yrs, colour = year_end) +
  geom_vline(xintercept = 0, colour = "#666666", linetype = "dotted") +
  geom_freqpoly(
    # bins = 100,
    position = "identity") +
  scale_x_continuous(
    limits = c(-40, 40)
    ) +
  scale_colour_manual(values = payback_pal) +
  theme_minimal(base_size = 12) +
  labs(
    x = "Payback period (years)\n(Positive: reducing debt)",
    y = "Number of people",
    colour = "Financial\nyear end",
    title = "Distribution of payback periods for HELP debt"
  )

# net reduction in debt
ggplot(finite_paybacks |> filter(!str_ends(year_end, "[*+]"))) +
  aes(x = net_reduction, colour = year_end) +
  geom_vline(xintercept = 0, colour = "#666666", linetype = "dotted") +
  geom_freqpoly(
    # bins = 100,
    position = "identity") +
  scale_x_continuous(
    limits = c(-2000, 2000)
    ) +
  scale_colour_manual(values = payback_pal) +
  theme_minimal(base_size = 12) +
  labs(
    x = "Net reduction in debt ($)\n(Positive: reducing debt)",
    y = "Number of people",
    colour = "Financial\nyear end",
    title = "Distribution of payback periods for HELP debt"
  )
```

I'm seeing some odd patterns in payback time for the latter years, so I'm going to run off some jittered points of reduction and payback period over time in the exploratory folder:

**EDIT:** yep, bad code reading in the more recent rates tables (due to different grouping separators) had repayment thresholds 1000x lower than they should have been. These are good diagnostic plots!

```{r}
#| label: jitter-changes
# warning - do not commit to version control (requires `output: true`)
ggplot(finite_paybacks) +
  aes(x = net_reduction, y = year_end) +
  geom_point(position = "jitter", size = 0.25, alpha = 0.025) +
  geom_violin(colour = "gold", alpha = 0.25) +
  geom_vline(xintercept = 0, colour = "red", linetype = "dotted") +
  labs(
    x = "Net reduction in debt",
    y = "Year") ->
netreduction_jitter

ggplot(finite_paybacks) +
  aes(x = income, y = year_end) +
  geom_point(position = "jitter", size = 0.25, alpha = 0.025) +
  geom_violin(colour = "gold", alpha = 0.25) +
  # geom_vline(xintercept = 0, colour = "red", linetype = "dotted") +
  labs(
    x = "Income",
    y = "Year") ->
income_jitter

ggplot(finite_paybacks) +
  aes(x = help_debt, y = year_end) +
  geom_point(position = "jitter", size = 0.25, alpha = 0.025) +
  geom_violin(colour = "gold", alpha = 0.25) +
  labs(
    x = "Income",
    y = "Year") ->
helpdebt_jitter

ggplot(finite_paybacks) +
  aes(x = repay_amount, y = year_end) +
  geom_point(position = "jitter", size = 0.25, alpha = 0.025) +
  geom_violin(colour = "gold", alpha = 0.25) +
  labs(
    x = "Repayment",
    y = "Year") ->
repayment_jitter

ggplot(finite_paybacks) +
  aes(x = index_amount, y = year_end) +
  geom_point(position = "jitter", size = 0.25, alpha = 0.025) +
  geom_violin(colour = "gold", alpha = 0.25) +
  labs(
    x = "Indexation",
    y = "Year") ->
indexation_jitter

ggplot(finite_paybacks) +
  aes(x = payback_yrs, y = year_end) +
  geom_point(position = "jitter", size = 0.25, alpha = 0.025) +
  geom_violin(colour = "gold", alpha = 0.25) +
  geom_vline(xintercept = 0, colour = "red", linetype = "dotted") +
  scale_x_continuous(transform = scales::pseudo_log_trans(base = 10)) +
  labs(
    x = "Payback time in years",
    y = "Year") ->
payback_jitter

ggsave(
  here("out", "explore", "jitter-netreduction.png"),
  netreduction_jitter,
  width = 1920, height = 1080, units = "px", bg = "white")

ggsave(
  here("out", "explore", "jitter-income.png"),
  income_jitter,
  width = 1920, height = 1080, units = "px", bg = "white")

ggsave(
  here("out", "explore", "jitter-helpdebt.png"),
  helpdebt_jitter,
  width = 1920, height = 1080, units = "px", bg = "white")

ggsave(
  here("out", "explore", "jitter-repayment.png"),
  repayment_jitter,
  width = 1920, height = 1080, units = "px", bg = "white")

ggsave(
  here("out", "explore", "jitter-indexation.png"),
  indexation_jitter,
  width = 1920, height = 1080, units = "px", bg = "white")

ggsave(
  here("out", "explore", "jitter-payback.png"),
  payback_jitter,
  width = 1920, height = 1080, units = "px", bg = "white")
```

Lots of stuff to digest here. Payback period is an interesting measure but maybe not great to do stats on.

Let's look at this two dimensionally instead:

```{r}
#| label: heatmaps-plain
ggplot(finite_paybacks) +
  aes(x = income, y = help_debt) +
  geom_bin_2d() +
  facet_wrap(vars(year_end)) +
  scale_x_continuous(trans = "log10",
    labels = scales::label_number(
      prefix = "$",
      scale_cut = scales::cut_short_scale()),
    ) +
  scale_y_continuous(trans = "log10",
    labels = scales::label_number(
      prefix = "$",
      scale_cut = scales::cut_short_scale()),
    ) +
  scale_fill_binned(trans = "log10") +
  labs(
    x = "Taxable income",
    y = "HELP debt balance",
    title = "Heatmap of HELP balances")
```

Hard to see too much change over time in this view, to be honest; the heatmap is not as useful as I'd imagined.

:::{.callout-note}
2017 looks a bit different to the other years. The ATO does a kind of clamping on extreme values to protect individuals' privacy; I think they've just done that at $1 for 2017 instead of $100 (the other years).
:::

It might be more useful if we overlay payback periods on it, since indexation is an important component!

```{r}
#| label: points-payback
# warning - this plot shouldn't be rendered to version control
# (and won't be, unless you add `output: true`)! it shows individual points
ggplot(finite_paybacks) +
  aes(x = income, y = help_debt) +
  geom_point(aes(colour = net_reduction), alpha = 0.1, size = 0.5) +
  facet_wrap(vars(year_end)) +
  scale_x_continuous(trans = "log10", labels = scales::label_currency(),
    limits = c(10000, 1000000)) +
  scale_y_continuous(trans = "log10", labels = scales::label_currency(),
    limits = c(500, 500000)) +
  scale_colour_gradient2(
    limits = c(-5000, 5000),
    oob = scales::squish) +
  theme_dark(base_size = 8) +
  labs(
    x = "Taxable income",
    y = "HELP debt balance",
    colour = "Net reduction in debt",
    title = "Distribution of HELP balances") ->
heatmap_paybacks

ggsave(
  here("out", "explore", "income-balance-payback-points.png"),
  heatmap_paybacks,
  width = 1920, height = 1080, units = "px", bg = "white")
```

Finally, let's look at a heatmap of indexation and repayment:

```{r}
#| label: heatmap-indexation-repayment
ggplot(finite_paybacks) +
  aes(x = repay_amount, y = index_amount) +
  geom_bin_2d() +
  geom_abline(slope = 1, intercept = 0, colour = "#333333",
    linetype = "dotted") +
  annotate("text", label = "Reducing debt",
    x = Inf, y = -Inf, hjust = 1, vjust = 0
    ) +
  annotate("text", label = "Increasing\ndebt",
    x = -Inf, y = Inf,
    hjust = 0, vjust = 1
    ) +
  facet_wrap(vars(year_end)) +
  scale_x_continuous(
    # trans = "log10",
    labels = scales::label_number(
      prefix = "$",
      scale_cut = scales::cut_short_scale()),
    ) +
  scale_y_continuous(
    # trans = "log10",
    labels = scales::label_number(
      prefix = "$",
      scale_cut = scales::cut_short_scale()),
    ) +
  coord_fixed(2) +
  scale_fill_continuous(
    # trans = "log10"
    ) +
  labs(
    x = "Compulsory repayment",
    y = "Indexation",
    title = "Heatmap of HELP movement")
```

### Binning

This might be easier to digest if we bin net deduction and payback period up. We can put people into categories:

- No debt (we'll calculate proportions with this both present and absent, as most people don't have debts)
- Debt went backwards (no repayment due to low income)
- Debt went backwards despite repayment (we could bin this up further)
- Debt basically went nowhere (indexation and repayment pretty balanced)
- Debt started going down (repayment exceeded indexation)

I'll also calculate margins of error here so we can put some rough confidence intervals on these proportions (the data look like they satisfy assumptions of normality in the above charts, at least for net reduction in debt).

```{r}
#| label: binning
unnested_payback |>
  mutate(
    help_category = case_when(
      help_debt < 1                    ~ "No debt",
      repay_amount < 1                 ~ "No repayment",
      net_reduction < -200              ~ "Debt grew despite payment",
      between(net_reduction, -200, 200) ~ "Indexation and repayment balanced",
      net_reduction > 200               ~ "Debt reduced"),
    calc_type = case_when(
      str_ends(year_end, fixed("+")) ~ "Projected with new policy",
      str_ends(year_end, fixed("*")) ~ "Projected from 2020-21 returns",
      TRUE ~ "From tax return sample")) ->
unnested_categories

# summarise first with no debts included...
unnested_categories |>
  group_by(year_end, calc_type, help_category) |>
  summarise(n = n()) |>
  mutate(
    p = n / sum(n, na.rm = TRUE),
    se = 1.9599 * sqrt(p * (1 - p) / n),
    p_upper = p + se,
    p_lower = p - se) |>
  write_csv(here("data", "stats-alltaxpayers.csv")) ->
props_alltaxpayers

# ... then with no debts removed
unnested_categories |>
  filter(help_category != "No debt") |>
  group_by(year_end, calc_type, help_category) |>
  summarise(n = n()) |>
  mutate(
    p = n / sum(n, na.rm = TRUE),
    se = 1.9599 * sqrt(p * (1 - p) / n),
    p_upper = p + se,
    p_lower = p - se) |>
  write_csv(here("data", "stats-alldebtors.csv")) ->
props_alldebtors
```

Let's see those proportions visualised:

```{r}
#| label: vis-stats-all-debtors
props_alldebtors |>
  mutate(year_int = as.integer(str_sub(year_end, 1, 4))) |>
  ungroup() |>
  ggplot() +
    aes(x = year_int, y = p, colour = help_category) +
    geom_point() +
    geom_line(aes(linetype = calc_type)) +
    scale_y_continuous(labels = scales::label_percent()) +
    scale_linetype_manual(
      values = c(
        "Projected with new policy" = "dotted",
        "Projected from 2020-21 returns" = "dashed",
        "From tax return sample" = "solid"),
      guide = guide_legend(nrow = 3, byrow = TRUE)) +
    scale_x_continuous(breaks = 2011:2024) +
    scale_colour_manual(
      values = c(
        "Debt grew despite payment" = "firebrick",
        "Debt reduced" = "green",
        "No repayment" = "grey",
        "Indexation and repayment balanced" = "gold"),
      guide = guide_legend(nrow = 3, byrow = TRUE)) +
    theme_minimal(base_size = 8) +
    theme(
      legend.position = "top",
      legend.direction = "horizontal") +
    labs(
      x = NULL, y = NULL,
      colour = NULL, linetype = NULL,
      title = "Repayment status of HELP loans") ->
stats_alldebtors_plot

ggsave(
  here("out", "explore", "stats-alldebtors.png"),
  stats_alldebtors_plot,
  width = 1920, height = 1080, units = "px", bg = "white")
```

I want to zoom in for exploration on the people whose debt went backwards. It looks like this is a new phenomenon, emerging in 2019 but now quite a big problem.

Let's repeat our earlier heatmaps with our new categories to see their income, HELP characteristics:


```{r}
#| label: points-payback
ggplot(unnested_categories) +
  aes(x = income, y = help_debt) +
  geom_point(aes(colour = help_category), alpha = 0.1, size = 0.5) +
  facet_wrap(vars(year_end)) +
  scale_x_continuous(trans = "log10", labels = scales::label_currency(),
    limits = c(10000, 1000000)) +
  scale_y_continuous(trans = "log10", labels = scales::label_currency(),
    limits = c(500, 500000)) +
  scale_colour_manual(
    values = c(
      "Debt grew despite payment" = "firebrick",
      "Debt reduced" = "green",
      "No repayment" = "grey",
      "Indexation and repayment balanced" = "gold")) +
  theme_dark(base_size = 8) +
  labs(
    x = "Taxable income",
    y = "HELP debt balance",
    colour = "Net reduction in debt",
    title = "Distribution of HELP balances") ->
heatmap_paybacks

ggsave(
  here("out", "explore", "income-debt-category-points.png"),
  heatmap_paybacks,
  width = 1920, height = 1080, units = "px", bg = "white")
```

