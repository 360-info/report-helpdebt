---
title: HELP loan analysis
subtitle: Interrogating HELP debts in the ATO individual sample files
format:
  360-analysis-html:
    # override for selected charts that do not expose individuals
    output: false
author: James Goldie
date: last-modified
code-fold: true
---

```{r}
#| label: setup
library(tidyverse)
library(RColorBrewer)
library(ggalt)
library(here)
dir.create(here("out", "explore"), showWarnings = FALSE, recursive = TRUE)
```

# Unzipping the data

Data is delivered as a `.7z` file, `Sample files 2011-12 to 20??-20??.7z` (covering from 2011-12 onward).

:::{.callout-note}
The 1% sample files from 2003-04 to 2010-11 don't appear to have information on HELP debt, only an indicator showing _whether_ they have a debt.
:::

The file has individual, nested ZIP files for each financial year that have their own passwords.

:::{.callout-warning}
For now I'm going to manually unzip these password-protected ZIP files, so the following code will assume that the unprotected CSV files are available somewhere under `/data/raw` as `20??_sample_file.csv`.

**These files are not version controlled; you must apply for access to them from the [Australian Taxation Office](https://www.ato.gov.au/about-ato/research-and-statistics/in-detail/taxation-statistics/taxation-statistics-previous-editions/taxation-statistics-2017-18/statistics/individuals/individuals-sample-files).
:::

## Exploration

```{r}
#| label: load-data
tibble(
  path = list.files(
    here("data", "raw"),
    pattern = "20.._sample_file\\.(csv|txt)",
    recursive = TRUE,
    full.names = TRUE)) |>
  mutate(
    year_end = str_extract(basename(path), "20.."),
    data = map(path, read_csv,
      col_select = c(Taxable_Income, Help_debt))) ->
nested_2pc
```

```{r}
#| label: combine
nested_2pc |>
  pull(data) |>
  set_names(nested_2pc$year_end) |>
  bind_rows(.id = "year_end") |>
  select(year_end, income = Taxable_Income, help_debt = Help_debt) ->
unnested_2pc
```

Let's start exploring HELP debt and income with some histograms (well, frequency polygons):

```{r}
#| label: explore-histograms
#| output: true
# extend colour palette to > 9 years
pal_YlGnBu <- brewer.pal(7, "YlGnBu") |> colorRampPalette()
pal_YlOrRd <- brewer.pal(7, "YlOrRd") |> colorRampPalette()
year_count <- unnested_2pc |> pull(year_end) |> unique() |> length() 
help_balance_pal <- pal_YlGnBu(year_count)
income_pal <- pal_YlOrRd(year_count)

ggplot(unnested_2pc) +
  aes(x = help_debt) +
  geom_freqpoly(aes(colour = year_end)) +
  scale_x_continuous(
    transform = "log10",
    guide = guide_axis_logticks(),
    labels = scales::label_number(
      prefix = "$",
      scale_cut = scales::cut_short_scale())) +
  scale_colour_manual(values = help_balance_pal) +
  scale_y_continuous(
    labels = scales::label_number(scale_cut = scales::cut_short_scale())) +
  theme_minimal(base_size = 18) +
  theme(axis.ticks.length.x = rel(3)) +
  labs(
    x = "HELP debt balance",
    y = "Number of people",
    colour = "Financial\nyear end",
    title = "Distribution of HELP balances over time")

ggplot(unnested_2pc) +
  aes(x = income) +
  geom_freqpoly(aes(colour = year_end)) +
  scale_x_continuous(
    transform = "log10",
    guide = guide_axis_logticks(),
    labels = scales::label_number(
      prefix = "$",
      scale_cut = scales::cut_short_scale())) +
  scale_y_continuous(
    labels = scales::label_number(scale_cut = scales::cut_short_scale())) +
  scale_colour_manual(values = income_pal) +
  theme_minimal(base_size = 18) +
  theme(axis.ticks.length.x = rel(3)) +
  labs(
    x = "Taxable income",
    y = "Number of people",
    colour = "Financial\nyear end",
    title = "Distribution of taxable income over time")
```

How many people from each sample even have a debt?

```{r}
#| label: has-debt-percentage
#| output: true
unnested_2pc |>
  group_by(year_end, has_help_debt = help_debt > 0) |>
  summarise(n = n()) |>
  mutate(prop = n / sum(n, na.rm = TRUE)) |>
  filter(has_help_debt == TRUE)
```

And the mean income and balance each year (including those for whom it's zero)?

```{r}
#| label: mean-income-balance
#| output: true
unnested_2pc |>
  group_by(year_end) |>
  summarise(
    mean_income = mean(income, na.rm = TRUE),
    mean_help_bal = mean(help_debt, na.rm = TRUE)) |>
  ungroup()
```

### Estimating 2022, 2023 and 2024 using FY2001 taxpayers

Because we don't have sample files beyond 2021, I'm going to use that latest sample file for 2022, 2023 and 2024 to see the effect of indexation rate (marking those years with `*`).

:::{.callout-important}
The Australian Government has announced that HELP debts will now be indexed according to the lowest of the Wage Price index and the Consumer Price Index. This change will retroactively be applied from FY2023.

I'll investigate the effect of this policy with the years marked `+` (still using the FY2021 returns).
:::

I've also added an `income_mult` argument, as further down I've estimated the effect of scaling incomes after 2021.

```{r}
#| label: estimate-2022-2024
replace_year <- function(df, year, income_mult = 1) {
  df |>
    filter(year_end == "2021") |>
      mutate(
        year_end = year,
        income = income * income_mult)
}

unnested_2pc |>
  bind_rows(
    unnested_2pc |> replace_year("2022*"),
    unnested_2pc |> replace_year("2023*"),
    unnested_2pc |> replace_year("2024*"),
    unnested_2pc |> replace_year("2023+"),
    unnested_2pc |> replace_year("2024+")) ->
unnested_estimated  
```

### Calculating indexation and mandatory repayment

The Parliamentary Library [keeps a historical record](https://www.aph.gov.au/About_Parliament/Parliamentary_Departments/Parliamentary_Library/pubs/rp/rp2021/Chronologies/HigherEducation#_Toc67381554) of HELP loan repayment rates. The ATO has [more recent tables](https://www.ato.gov.au/tax-rates-and-codes/study-and-training-support-loans-rates-and-repayment-thresholds).

:::{.callout-note}
These tables are saved in `/data`. You may need to re-retrieve them if you're reproducing this analysis in later years.
:::

:::{.callout-warning}
For this analysis, I'm simply using taxable income as the measure for repayment. In reality, a few other items are considered:

- plus net rental losses (from 1996)
- plus total reportable fringe benefits amounts (from 1999)
- deduct exempt foreign employment income (from 2005)
- plus any total investment loss (which includes net rental losses) (from 2009)
- plus reportable super contributions (from 2009)
:::

Let's tidy up the repayment rate tables. Note that the top rate for each year is a _starting threshold_, so we'll change those to be infinite:

```{r}
#| label: get-repayment-rates
here("data", "raw", "repayment-rates-2004-2019.csv") |>
  read_csv(col_types = "ccc") |>
  pivot_longer(-Year, names_to = "rate", values_to = "threshold") |>
  mutate(
    year_end = paste0("20", str_sub(Year, 6, 7)),
    rate = if_else(rate == "Nil", "0", rate),
    rate = rate |>
      parse_number(locale = locale(grouping_mark = " ")) |>
      (\(x) x / 100)(),
    threshold = parse_number(threshold,
      locale = locale(grouping_mark = " "))) |>
  select(year_end, rate, threshold) |>
  filter(!is.na(threshold)) ->
repayment_rates_oldest

here("data", "raw", "repayment-rates-2019-2021.csv") |>
  read_csv(col_types = "ccc") |>
  pivot_longer(-Rate, names_to = "Year", values_to = "threshold") |>
  mutate(
    year_end = paste0("20", str_sub(Year, 6, 7)),
    rate = if_else(Rate == "Nil", "0", Rate),
    rate = rate |>
      parse_number(locale = locale(grouping_mark = " ")) |>
      (\(x) x / 100)(),
    threshold = parse_number(threshold,
      locale = locale(grouping_mark = " "))) |>
  select(year_end, rate, threshold) |>
  filter(!is.na(threshold)) ->
repayment_rates_older

# FY2022-2024
tidy_ratetables <- function(path, suffix = c("*", "+")) {
  suffix <- match.arg(suffix)
  year <- paste0(str_extract(basename(path), "20.."), suffix)
  
  # read, turn thresholds into upper limits
  # (note differing kinds of hyphens in each table!)
  read_csv(path, col_types = "cc") |>
    mutate(
      year_end = year,
      threshold = `Repayment income (RI)` |>
        str_remove_all("\\$[\\d,]{1,9} \\p{Pd} ") |>
        str_replace_all(c(
          "Below " = "",
          " and above" = "")) |>
        parse_number(),
      # rate: nil => 0, drop %, / 100
      rate = if_else(`Repayment rate` == "Nil", "0", `Repayment rate`),
      rate = rate |>
        parse_number(locale = locale(grouping_mark = " ")) |>
        (\(x) x / 100)()) |>
    select(year_end, threshold, rate)
}

tibble(
  path = list.files(here("data", "raw"),
    pattern = glob2rx("repayment-rates-FY20??.csv"),
    full.names = TRUE)) ->
rate_table_files_newest

rate_table_files_newest |>
  mutate(data = map(path, tidy_ratetables)) |>
  unnest(data) |>
  select(-path) ->
repayment_rates_new

rate_table_files_newest |>
  filter(str_detect(path, regex("(23|24)"))) |>
  mutate(data = map(path, tidy_ratetables, suffix = "+")) |>
  unnest(data) |>
  select(-path) ->
repayment_rates_new_alppolicy
  

# combine the rates (set upper rates to inf)
repayment_rates_oldest |>
  bind_rows(repayment_rates_older) |>
  bind_rows(repayment_rates_new) |>
  bind_rows(repayment_rates_new_alppolicy) |>
  rename(repay_rate = rate, repay_threshold = threshold) |>
  group_by(year_end) |>
  mutate(repay_threshold =
    if_else(repay_rate == max(repay_rate, na.rm = TRUE), Inf, repay_threshold)) |>
  write_csv(here("data", "repayment-rates.csv"))->
repayment_rates
```

Now we can apply them to our individual sample to work out repayment obligations based on people's incomes.

Since repayments are not progressive, we can use a rolling join to identify the relevant threshold and rate:

```{r}
#| label: calculate-repayments
unnested_estimated |>
  left_join(repayment_rates, join_by(
    year_end == year_end,
    closest(income <= repay_threshold))) |>
  mutate(repay_amount = help_debt * repay_rate) ->
unnested_repayments
```

Now let's handle indexation. This one is a fixed rate of taxable income each year. The ATO has [a table of historical indexation rates](https://www.ato.gov.au/tax-rates-and-codes/study-and-training-support-loans-indexation-rates) going back to 2013 (not ideal, but until 2011, the Higher Education Operations Grant index was used).

:::{.callout-note}
Reporting of the Australian Government's announcement that HELP loans will retroactively follow the lower of CPI and WPI from FY2023 notes that last year's 7.1% indexation will be reduced to 3.2%.

This year's was expected to be 4.7% on the basis of the CPI, but the latest WPI isn't out yet (latest release is December, and the March quarter is released on May 15).

As of the December release, annual WPI had risen to 4.2%. I'm going to use that figure for now, but it looks like WPI has been trending up since the pandemic — it could be that that figure lands close to 4.7% and hardly moves at all.
:::

```{r}
#| label: indexation-rates
tribble(
  ~ year_end, ~ index_rate,
  "2024+",    0.042,
  "2023+",    0.032,
  "2024*",    0.047,
  "2023*",    0.071,
  "2022*",    0.039,
  "2021",     0.006,
  "2020",     0.018,
  "2019",     0.018,
  "2018",     0.019,
  "2017",     0.015,
  "2016",     0.015,
  "2015",     0.021,
  "2014",     0.026,
  "2013",     0.020) ->
indexation_rates
```

Let's do another rolling join to the tax returns. Then, once we have both repayment amount and indexation amount, we'll work out net change and divide it by the balance to work out number of years to repay (obviously this assumes no future change to thresholds or income):

```{r}
#| label: calculate-indexation
unnested_repayments |>
  left_join(indexation_rates, join_by(year_end == year_end)) |>
  mutate(index_amount = help_debt * index_rate) |>
  filter(!is.na(index_rate)) |>
  # calc net change and repayment time
  mutate(
    net_reduction = repay_amount - index_amount,
    payback_yrs = help_debt / net_reduction) ->
unnested_payback
```

### Visualise debt changes and payback periods

Let's try some visualisations to see this payback distribution. (We'll need to remove the people with no debt.) I'd particularly like to check assumptions of normality here:

```{r}
#| label: vis-payback
#| output: true
unnested_payback |>
  filter(help_debt > 0) |>
  mutate(
    repaying = payback_yrs > 0,
    payback_yrs_abs = abs(payback_yrs)) ->
finite_paybacks

# extend palette
pal_PuRd <- brewer.pal(7, "PuRd") |> colorRampPalette()
year_count_ext <- finite_paybacks |> pull(year_end) |> unique() |> length() 
payback_pal <- pal_PuRd(year_count_ext)

# payback period
ggplot(finite_paybacks |> filter(!str_ends(year_end, "[*+]"))) +
  aes(x = payback_yrs, colour = year_end) +
  geom_vline(xintercept = 0, colour = "#666666", linetype = "dotted") +
  geom_freqpoly(
    # bins = 100,
    position = "identity") +
  scale_x_continuous(
    limits = c(-40, 40)
    ) +
  scale_colour_manual(values = payback_pal) +
  theme_minimal(base_size = 12) +
  labs(
    x = "Payback period (years)\n(Positive: reducing debt)",
    y = "Number of people",
    colour = "Financial\nyear end",
    title = "Distribution of payback periods for HELP debt"
  )

# net reduction in debt
ggplot(finite_paybacks |> filter(!str_ends(year_end, "[*+]"))) +
  aes(x = net_reduction, colour = year_end) +
  geom_vline(xintercept = 0, colour = "#666666", linetype = "dotted") +
  geom_freqpoly(
    # bins = 100,
    position = "identity") +
  scale_x_continuous(
    limits = c(-2000, 2000)
    ) +
  scale_colour_manual(values = payback_pal) +
  theme_minimal(base_size = 12) +
  labs(
    x = "Net reduction in debt ($)\n(Positive: reducing debt)",
    y = "Number of people",
    colour = "Financial\nyear end",
    title = "Distribution of payback periods for HELP debt"
  )
```

I'm seeing some odd patterns in payback time for the latter years, so I'm going to run off some jittered points of reduction and payback period over time in the exploratory folder:

**EDIT:** yep, bad code reading in the more recent rates tables (due to different grouping separators) had repayment thresholds 1000x lower than they should have been. These are good diagnostic plots!

```{r}
#| label: cat
unnested_payback |>
  mutate(
    help_category = case_when(
      help_debt < 1                    ~ "No debt",
      repay_amount < 1                 ~ "No repayment",
      net_reduction < -200              ~ "Debt grew despite payment",
      between(net_reduction, -200, 200) ~ "Indexation and repayment balanced",
      net_reduction > 200               ~ "Debt reduced"),
    calc_type = case_when(
      str_ends(year_end, fixed("+")) ~ "Projected with new policy",
      str_ends(year_end, fixed("*")) ~ "Projected from 2020-21 returns",
      TRUE ~ "From tax return sample")) ->
categorised_payback
```

```{r}
#| label: jitter-changes
# warning - do not commit to version control (requires `output: true`)
ggplot(categorised_payback) +
  aes(x = net_reduction, y = year_end, colour = help_category) +
  geom_point(position = "jitter", size = 0.25, alpha = 0.025) +
  geom_vline(xintercept = 0, colour = "red", linetype = "dotted") +
  scale_colour_manual(
    values = c(
      "Debt grew despite payment" = "#f03b20",
      "Debt reduced" = "#2ca25f",
      "No repayment" = "grey",
      "Indexation and repayment balanced" = "#fed976"),
    guide = guide_legend(nrow = 3, byrow = TRUE)) +
  theme(
    legend.position = "top",
    legend.direction = "horizontal"
  ) +
  guides(color = guide_legend(override.aes = list(alpha = 1))) +
  labs(
    x = "Net reduction in debt",
    y = "Year") ->
netreduction_jitter

ggplot(categorised_payback) +
  aes(x = income, y = year_end, colour = help_category) +
  geom_point(position = "jitter", size = 0.25, alpha = 0.025) +
  # geom_vline(xintercept = 0, colour = "red", linetype = "dotted") +
  scale_colour_manual(
    values = c(
      "Debt grew despite payment" = "#f03b20",
      "Debt reduced" = "#2ca25f",
      "No repayment" = "grey",
      "Indexation and repayment balanced" = "#fed976"),
    guide = guide_legend(nrow = 3, byrow = TRUE)) +
  theme(
    legend.position = "top",
    legend.direction = "horizontal"
  ) +
  guides(color = guide_legend(override.aes = list(alpha = 1))) +
  labs(
    x = "Income",
    y = "Year") ->
income_jitter

ggplot(categorised_payback) +
  aes(x = help_debt, y = year_end, colour = help_category) +
  geom_point(position = "jitter", size = 0.25, alpha = 0.025) +
  scale_colour_manual(
    values = c(
      "Debt grew despite payment" = "#f03b20",
      "Debt reduced" = "#2ca25f",
      "No repayment" = "grey",
      "Indexation and repayment balanced" = "#fed976"),
    guide = guide_legend(nrow = 3, byrow = TRUE)) +
  theme(
    legend.position = "top",
    legend.direction = "horizontal"
  ) +
  guides(color = guide_legend(override.aes = list(alpha = 1))) +
  labs(
    x = "Income",
    y = "Year") ->
helpdebt_jitter

ggplot(categorised_payback) +
  aes(x = repay_amount, y = year_end, colour = help_category) +
  geom_point(position = "jitter", size = 0.25, alpha = 0.025) +
  scale_colour_manual(
    values = c(
      "Debt grew despite payment" = "#f03b20",
      "Debt reduced" = "#2ca25f",
      "No repayment" = "grey",
      "Indexation and repayment balanced" = "#fed976"),
    guide = guide_legend(nrow = 3, byrow = TRUE)) +
  theme(
    legend.position = "top",
    legend.direction = "horizontal"
  ) +
  guides(color = guide_legend(override.aes = list(alpha = 1))) +
  labs(
    x = "Repayment",
    y = "Year") ->
repayment_jitter

ggplot(categorised_payback) +
  aes(x = index_amount, y = year_end, colour = help_category) +
  geom_point(position = "jitter", size = 0.25, alpha = 0.025) +
  scale_colour_manual(
    values = c(
      "Debt grew despite payment" = "#f03b20",
      "Debt reduced" = "#2ca25f",
      "No repayment" = "grey",
      "Indexation and repayment balanced" = "#fed976"),
    guide = guide_legend(nrow = 3, byrow = TRUE)) +
  theme(
    legend.position = "top",
    legend.direction = "horizontal"
  ) +
  guides(color = guide_legend(override.aes = list(alpha = 1))) +
  labs(
    x = "Indexation",
    y = "Year") ->
indexation_jitter

ggplot(categorised_payback) +
  aes(x = payback_yrs, y = year_end, colour = help_category) +
  geom_point(position = "jitter", size = 0.25, alpha = 0.025) +
  geom_vline(xintercept = 0, colour = "red", linetype = "dotted") +
  scale_colour_manual(
    values = c(
      "Debt grew despite payment" = "#f03b20",
      "Debt reduced" = "#2ca25f",
      "No repayment" = "grey",
      "Indexation and repayment balanced" = "#fed976"),
    guide = guide_legend(nrow = 3, byrow = TRUE)) +
  scale_x_continuous(transform = scales::pseudo_log_trans(base = 10)) +
  theme(
    legend.position = "top",
    legend.direction = "horizontal"
  ) +
  guides(color = guide_legend(override.aes = list(alpha = 1))) +
  labs(
    x = "Payback time in years",
    y = "Year") ->
payback_jitter

ggsave(
  here("out", "explore", "jitter-netreduction.png"),
  netreduction_jitter,
  width = 1920, height = 1080, units = "px", bg = "white", scale = 2)

ggsave(
  here("out", "explore", "jitter-income.png"),
  income_jitter,
  width = 1920, height = 1080, units = "px", bg = "white", scale = 2)

ggsave(
  here("out", "explore", "jitter-helpdebt.png"),
  helpdebt_jitter,
  width = 1920, height = 1080, units = "px", bg = "white", scale = 2)

ggsave(
  here("out", "explore", "jitter-repayment.png"),
  repayment_jitter,
  width = 1920, height = 1080, units = "px", bg = "white", scale = 2)

ggsave(
  here("out", "explore", "jitter-indexation.png"),
  indexation_jitter,
  width = 1920, height = 1080, units = "px", bg = "white", scale = 2)

ggsave(
  here("out", "explore", "jitter-payback.png"),
  payback_jitter,
  width = 1920, height = 1080, units = "px", bg = "white", scale = 2)
```

Lots of stuff to digest here. Payback period is an interesting measure but maybe not great to do stats on.

Let's look at this two dimensionally instead:

```{r}
#| label: heatmaps-plain
ggplot(finite_paybacks) +
  aes(x = income, y = help_debt) +
  geom_bin_2d() +
  facet_wrap(vars(year_end)) +
  scale_x_continuous(trans = "log10",
    labels = scales::label_number(
      prefix = "$",
      scale_cut = scales::cut_short_scale()),
    ) +
  scale_y_continuous(trans = "log10",
    labels = scales::label_number(
      prefix = "$",
      scale_cut = scales::cut_short_scale()),
    ) +
  scale_fill_binned(trans = "log10") +
  labs(
    x = "Taxable income",
    y = "HELP debt balance",
    title = "Heatmap of HELP balances")
```

Hard to see too much change over time in this view, to be honest; the heatmap is not as useful as I'd imagined.

:::{.callout-note}
2017 looks a bit different to the other years. The ATO does a kind of clamping on extreme values to protect individuals' privacy; I think they've just done that at $1 for 2017 instead of $100 (the other years).
:::

It might be more useful if we overlay payback periods on it, since indexation is an important component!

```{r}
#| label: points-payback
# warning - this plot shouldn't be rendered to version control
# (and won't be, unless you add `output: true`)! it shows individual points
ggplot(finite_paybacks) +
  aes(x = income, y = help_debt) +
  geom_point(aes(colour = net_reduction), alpha = 0.1, size = 0.5) +
  facet_wrap(vars(year_end)) +
  scale_x_continuous(trans = "log10", labels = scales::label_currency(),
    limits = c(10000, 1000000)) +
  scale_y_continuous(trans = "log10", labels = scales::label_currency(),
    limits = c(500, 500000)) +
  scale_colour_gradient2(
    limits = c(-5000, 5000),
    oob = scales::squish) +
  theme_dark(base_size = 8) +
  labs(
    x = "Taxable income",
    y = "HELP debt balance",
    colour = "Net reduction in debt",
    title = "Distribution of HELP balances") ->
heatmap_paybacks

ggsave(
  here("out", "explore", "income-balance-payback-points.png"),
  heatmap_paybacks,
  width = 1920, height = 1080, units = "px", bg = "white")
```

Finally, let's look at a heatmap of indexation and repayment:

```{r}
#| label: heatmap-indexation-repayment
ggplot(finite_paybacks) +
  aes(x = repay_amount, y = index_amount) +
  geom_bin_2d() +
  geom_abline(slope = 1, intercept = 0, colour = "#333333",
    linetype = "dotted") +
  annotate("text", label = "Reducing debt",
    x = Inf, y = -Inf, hjust = 1, vjust = 0
    ) +
  annotate("text", label = "Increasing\ndebt",
    x = -Inf, y = Inf,
    hjust = 0, vjust = 1
    ) +
  facet_wrap(vars(year_end)) +
  scale_x_continuous(
    # trans = "log10",
    labels = scales::label_number(
      prefix = "$",
      scale_cut = scales::cut_short_scale()),
    ) +
  scale_y_continuous(
    # trans = "log10",
    labels = scales::label_number(
      prefix = "$",
      scale_cut = scales::cut_short_scale()),
    ) +
  coord_fixed(2) +
  scale_fill_continuous(
    # trans = "log10"
    ) +
  labs(
    x = "Compulsory repayment",
    y = "Indexation",
    title = "Heatmap of HELP movement")
```

### Binning

This might be easier to digest if we bin net deduction and payback period up. We can put people into categories:

- No debt (we'll calculate proportions with this both present and absent, as most people don't have debts)
- Debt went backwards (no repayment due to low income)
- Debt went backwards despite repayment (we could bin this up further)
- Debt basically went nowhere (indexation and repayment pretty balanced)
- Debt started going down (repayment exceeded indexation)

I'll also calculate margins of error here so we can put some rough confidence intervals on these proportions (the data look like they satisfy assumptions of normality in the above charts, at least for net reduction in debt).

```{r}
#| label: binning
unnested_payback |>
  mutate(
    help_category = case_when(
      help_debt < 1                    ~ "No debt",
      repay_amount < 1                 ~ "No repayment",
      net_reduction < -200              ~ "Debt grew despite payment",
      between(net_reduction, -200, 200) ~ "Indexation and repayment balanced",
      net_reduction > 200               ~ "Debt reduced"),
    calc_type = case_when(
      str_ends(year_end, fixed("+")) ~ "Projected with new policy",
      str_ends(year_end, fixed("*")) ~ "Projected from 2020-21 returns",
      TRUE ~ "From tax return sample")) ->
unnested_categories

# summarise first with no debts included...
unnested_categories |>
  group_by(year_end, calc_type, help_category) |>
  summarise(n = n()) |>
  mutate(
    p = n / sum(n, na.rm = TRUE),
    se = 1.9599 * sqrt(p * (1 - p) / n),
    p_upper = p + se,
    p_lower = p - se) |>
  write_csv(here("data", "stats-alltaxpayers.csv")) ->
props_alltaxpayers

# ... then with no debts removed
unnested_categories |>
  filter(help_category != "No debt") |>
  group_by(year_end, calc_type, help_category) |>
  summarise(n = n()) |>
  mutate(
    p = n / sum(n, na.rm = TRUE),
    se = 1.9599 * sqrt(p * (1 - p) / n),
    p_upper = p + se,
    p_lower = p - se) |>
  write_csv(here("data", "stats-alldebtors.csv")) ->
props_alldebtors
```

Let's see those proportions visualised:

```{r}
#| label: vis-stats-all-debtors
props_alldebtors |>
  mutate(year_int = as.integer(str_sub(year_end, 1, 4))) |>
  ungroup() |>
  ggplot() +
    aes(x = year_int, y = p, colour = help_category) +
    geom_point() +
    geom_line(aes(linetype = calc_type)) +
    scale_y_continuous(labels = scales::label_percent()) +
    scale_linetype_manual(
      values = c(
        "Projected with new policy" = "dotted",
        "Projected from 2020-21 returns" = "dashed",
        "From tax return sample" = "solid"),
      guide = guide_legend(nrow = 3, byrow = TRUE)) +
    scale_x_continuous(breaks = 2011:2024) +
    scale_colour_manual(
      values = c(
        "Debt grew despite payment" = "firebrick",
        "Debt reduced" = "green",
        "No repayment" = "grey",
        "Indexation and repayment balanced" = "gold"),
      guide = guide_legend(nrow = 3, byrow = TRUE)) +
    theme_minimal(base_size = 8) +
    theme(
      legend.position = "top",
      legend.direction = "horizontal",
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank()) +
    labs(
      x = NULL, y = NULL,
      colour = NULL, linetype = NULL,
      title = "Repayment status of HELP loans") ->
stats_alldebtors_plot

ggsave(
  here("out", "explore", "stats-alldebtors.png"),
  stats_alldebtors_plot,
  width = 1920, height = 1080, units = "px", bg = "white")
```

I want to zoom in for exploration on the people whose debt went backwards. It looks like this is a new phenomenon, emerging in 2019 but now quite a big problem.

Let's repeat our earlier heatmaps with our new categories to see their income, HELP characteristics:


```{r}
#| label: points-payback
ggplot(unnested_categories) +
  aes(x = income, y = help_debt) +
  geom_point(aes(colour = help_category), alpha = 0.02, size = 0.25) +
  facet_wrap(vars(year_end)) +
  scale_x_continuous(trans = "log10", labels = scales::label_currency(),
    limits = c(10000, 1000000)) +
  scale_y_continuous(trans = "log10", labels = scales::label_currency(),
    limits = c(500, 500000)) +
  scale_colour_manual(
    values = c(
      "Debt grew despite payment" = "firebrick",
      "Debt reduced" = "green",
      "No repayment" = "grey",
      "Indexation and repayment balanced" = "gold")) +
  theme_minimal(base_size = 8) +
  labs(
    x = "Taxable income",
    y = "HELP debt balance",
    colour = "Net reduction in debt",
    title = "Distribution of HELP balances by status") ->
heatmap_paybacks

ggsave(
  here("out", "explore", "income-debt-category-points.png"),
  heatmap_paybacks,
  width = 1920, height = 1080, units = "px", bg = "white")
```

### Adjusting income

There appears to be something starting to appear since 2020: a category of people going backwards despite making payments on their debts. They appear in 2020, disappear in 2021, then reappear from 2022 onward in greater numbers.

One thing we should note here is that we're using 2021 incomes for future years. It might be worth trying to estimate the effect this has on things.

I'm going to use the Wage Price Index to scale the incomes in our 2021 sample. HELP loans have probably changed too, but that might be harder to estimate (we might potentially be able to do it from headline figures).


```{r}
#| label: scale-income
unnested_2pc |>
  bind_rows(
    unnested_2pc |> replace_year("2022*", income_mult = 1.027),
    unnested_2pc |> replace_year("2023*", income_mult = 1.027 * 1.037),
    unnested_2pc |> replace_year("2024*", income_mult = 1.027 * 1.037 * 1.042),
    unnested_2pc |> replace_year("2023+", income_mult = 1.027 * 1.037),
    unnested_2pc |> replace_year("2024+", income_mult = 1.027 * 1.037 * 1.042)) ->
unnested_scaled

# now repeat merging repayment and indexation info

unnested_scaled |>
  left_join(repayment_rates, join_by(
    year_end == year_end,
    closest(income <= repay_threshold))) |>
  mutate(repay_amount = help_debt * repay_rate) ->
unnested_repayments_scaled

unnested_repayments_scaled |>
  left_join(indexation_rates, join_by(year_end == year_end)) |>
  mutate(index_amount = help_debt * index_rate) |>
  filter(!is.na(index_rate)) |>
  # calc net change and repayment time
  mutate(
    net_reduction = repay_amount - index_amount,
    payback_yrs = help_debt / net_reduction) ->
unnested_payback_scaled
```

Now let's repeat our stats and charts:

```{r}
#| label: binning-scaled
unnested_payback_scaled |>
  mutate(
    help_category = case_when(
      help_debt < 1                    ~ "No debt",
      repay_amount < 1                 ~ "No repayment",
      net_reduction < -200              ~ "Debt grew despite payment",
      between(net_reduction, -200, 200) ~ "Indexation and repayment balanced",
      net_reduction > 200               ~ "Debt reduced"),
    calc_type = case_when(
      str_ends(year_end, fixed("+")) ~ "Projected with new policy",
      str_ends(year_end, fixed("*")) ~ "Projected from 2020-21 returns",
      TRUE ~ "From tax return sample")) ->
unnested_categories_scaled

# summarise first with no debts included...
unnested_categories_scaled |>
  group_by(year_end, calc_type, help_category) |>
  summarise(n = n()) |>
  mutate(
    p = n / sum(n, na.rm = TRUE),
    se = 1.9599 * sqrt(p * (1 - p) / n),
    p_upper = p + se,
    p_lower = p - se) |>
  write_csv(here("data", "stats-alltaxpayers-scaled.csv")) ->
props_alltaxpayers_scaled

# ... then with no debts removed
unnested_categories_scaled |>
  filter(help_category != "No debt") |>
  group_by(year_end, calc_type, help_category) |>
  summarise(n = n()) |>
  mutate(
    p = n / sum(n, na.rm = TRUE),
    se = 1.9599 * sqrt(p * (1 - p) / n),
    p_upper = p + se,
    p_lower = p - se) |>
  write_csv(here("data", "stats-alldebtors-scaled.csv")) ->
props_alldebtors_scaled
```

```{r}
#| label: vis-stats-all-debtors-scaled
props_alldebtors_scaled |>
  mutate(year_int = as.integer(str_sub(year_end, 1, 4))) |>
  ungroup() |>
  ggplot() +
    aes(x = year_int, y = p, colour = help_category) +
    geom_point() +
    geom_line(aes(linetype = calc_type)) +
    scale_y_continuous(labels = scales::label_percent()) +
    scale_linetype_manual(
      values = c(
        "Projected with new policy" = "dotted",
        "Projected from 2020-21 returns" = "dashed",
        "From tax return sample" = "solid"),
      guide = guide_legend(nrow = 3, byrow = TRUE)) +
    scale_x_continuous(breaks = 2011:2024) +
    scale_colour_manual(
      values = c(
        "Debt grew despite payment" = "#f03b20",
        "Debt reduced" = "#2ca25f",
        "No repayment" = "grey",
        "Indexation and repayment balanced" = "#fed976"),
      guide = guide_legend(nrow = 3, byrow = TRUE)) +
    theme_360() +
    theme(
      legend.position = "top",
      legend.direction = "horizontal",
      legend.margin = margin(0),
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank(),
      panel.grid.minor.y = element_blank()) +
    labs(
      x = NULL, y = "Proportion of HELP loans",
      colour = NULL, linetype = NULL,
      title = "Repayment status of HELP loans",
      subtitle = paste(
        "Since 2019, rising indexation has created a class of people whose <span style='color: #f03b20;'>**HELP debts rise**</span> despite them making",
        "mandatory payments",
        sep = "<br>"),
      caption = paste(
        "**CHART**: James Goldie, 360info",
        "**DATA:** Australian Taxation Office",
        "2022-2024 incomes adjusted from 2021 for WPI",
        sep = "<br>")) ->
stats_alldebtors_plot_scaled

save_360plot(stats_alldebtors_plot_scaled,
  here("out", "stats-alldebtors-scaled-final.png"))
save_360plot(stats_alldebtors_plot_scaled,
  here("out", "stats-alldebtors-scaled-final.svg"))
```

### Wide for Datawrapper/Flourish

Let's pivot the central estimates wide for Datawrapper and Flourish:


```{r}
#| label: widen
props_alldebtors |>
  mutate(policy = case_match(calc_type,
    "From tax return sample" ~ "Before 2024 pre-budget policy",
    "Projected from 2020-21 returns" ~ "Before 2024 pre-budget policy",
    "Projected with new policy" ~ "After 2024 pre-budget policy")) |>
  ungroup() |>
  select(year_end, policy, help_category, p) |>
  pivot_wider(names_from = help_category, values_from = p) |>
  write_csv(here("data", "stats-alldebtors-wide.csv"))
```

### Mapping out the income and debt characteristics of movement categories

I'd like to make a heatmap that really shows where these categories lie. Instead of using on the existing data, which puts the focus on the frequency of these categories, let's just map out all the income/debt combos increments and apply the 2024 repayment and indexation rates to them.

```{r}
#| label: synthetic-data
expand_grid(
  year_end = c("2023*", "2023+"),
  income = seq(0, 150000, by = 1000),
  help_debt = seq(0, 100000, by = 500)) ->
synthetic

# get the repayment rates under both scenarios for just 2024

repayment_rates_new |>
  filter(year_end == "2023*") |>
  mutate(repay_threshold =
    if_else(rate == max(rate, na.rm = TRUE), Inf, threshold)) |>
  select(year_end, repay_rate = rate, repay_threshold) ->
latest_repayment_rates_nopolicy

repayment_rates_new_alppolicy |>
  filter(year_end == "2023+") |>
  mutate(repay_threshold =
    if_else(rate == max(rate, na.rm = TRUE), Inf, threshold)) |>
  select(year_end, repay_rate = rate, repay_threshold) ->
latest_repayment_rates_alppolicy

latest_repayment_rates <-
  bind_rows(latest_repayment_rates_nopolicy, latest_repayment_rates_alppolicy)

indexation_rates |>
  filter(str_detect(year_end, "2023")) ->
latest_indexation_rates

# now join them all

synthetic |>
  # first repayments...
  left_join(latest_repayment_rates, join_by(
    year_end == year_end,
    closest(income <= repay_threshold))) |>
  mutate(repay_amount = help_debt * repay_rate) |>
  # ... then indexation
  left_join(indexation_rates, join_by(year_end == year_end)) |>
  mutate(index_amount = help_debt * index_rate) |>
  # and then calc net change and repayment time and categorise
  mutate(
    net_reduction = repay_amount - index_amount,
    help_category = case_when(
      help_debt < 1                    ~ "No debt",
      repay_amount < 1                 ~ "No repayment (low income)",
      net_reduction < -200              ~ "Debt grew despite payment",
      between(net_reduction, -200, 200) ~ "Indexation and repayment balanced",
      net_reduction > 200               ~ "Debt reduced"),
    scenario = case_match(year_end,
      "2023*" ~ "Before 2024 pre-budget policy: 7.1% indexation",
      "2023+" ~ "With 2024 pre-budget policy: 3.2% indexation")) ->
synthetic_categories

# visualise

ggplot(synthetic_categories) +
  aes(x = income, y = help_debt) +
  geom_raster(aes(fill = help_category)) +
  facet_wrap(vars(scenario)) +
  scale_fill_manual(
    values = c(
      "Debt grew despite payment" = "#c7321c",
      "Debt reduced" = "#5acc8b",
      "No repayment (low income)" = "grey",
      "Indexation and repayment balanced" = "#fed976"),
    guide = guide_legend(nrow = 1, byrow = TRUE)) +
  scale_x_continuous(
    expand = expansion(),
    labels = scales::label_currency()) +
  scale_y_continuous(
    expand = expansion(),
    labels = scales::label_currency()) +
  theme_360(base_size = 12) +
  theme(
    legend.direction = "horizontal",
    legend.position = "top",
    panel.ontop = TRUE,
    panel.grid.major = element_line(colour = "#00000055"),
    panel.grid.minor = element_line(colour = "#00000055"),
    panel.border = element_rect(colour = "black", fill = NA),
    panel.spacing = unit(2, "lines"),
    strip.text = element_text(face = "bold", hjust = 0, size = rel(1.15))) +
  labs(
    x = "Income",
    y = "HELP loan balance",
    fill = NULL,
    title = "HELP loans didn't go backwards before 2020",
    # subtitle = "Before 2020, the combination of repayment rates and indexation levels ensured that if you were making mandatory payments, your balance never rose.",
    subtitle = "Debts that \"go backwards\" to remain last year for some people earning $50,000–70,000 despite new policy",
    caption = paste(
      "**CHART:** James Goldie, 360info",
      "**DATA:** Australian Taxation Office",
      sep = "<br>")) ->
synthetic_heatmap

save_360plot(synthetic_heatmap,
  here("out", "synth-heatmap-2023.png"), shape = "sdtv-landscape")
save_360plot(synthetic_heatmap,
  here("out", "synth-heatmap-2023.svg"), shape = "sdtv-landscape")
```

### Repayment rates over time

Although indexation is a big part of this, the changing repayment rates are also a big component. Let's visualise those too.


```{r}
repayment_rates |>
  filter(!str_detect(year_end, fixed("+"))) |>
  rename(threshold_upper = repay_threshold) |>
  arrange(year_end, repay_rate) |>
  group_by(year_end) |>
  mutate(
    year_end = as.integer(str_remove(year_end, fixed("*"))),
    threshold_lower = lag(threshold_upper, 1)) |>
  replace_na(list(threshold_lower = 0)) ->
repayment_ranges

pal_YlGnBu <- brewer.pal(7, "YlGnBu") |> colorRampPalette()
year_count <- repayment_ranges |> pull(repay_rate) |> unique() |> length() 
repay_rate_pal <- pal_YlGnBu(year_count)

repayment_ranges |>
  ungroup() |>
  mutate(
    repay_rate_fct = factor(repay_rate,
      levels = seq(0, 0.1, by = 0.005),
      labels = seq(0, 0.1, by = 0.005) |> scales::percent()),
    repay_rate_fct = fct_drop(repay_rate_fct),
    threshold_upper =
      if_else(is.infinite(threshold_upper), 200000, threshold_upper)
  ) |>
  ggplot() +
    aes(x = year_end, fill = repay_rate_fct) +
    geom_ribbon(aes(ymin = threshold_lower, ymax = threshold_upper),
      colour = "#00000044",
      stat = "stepribbon") +
    scale_fill_manual(values = c("white", repay_rate_pal)) +
    scale_x_continuous(expand = expansion()) +
    scale_y_continuous(expand = expansion(), labels = scales::label_currency()) +
    coord_cartesian(ylim = c(NA, 160000)) +
    annotate_360_glasslight(
      x = 2006.5, y = 20000, hjust = 0,
      label = paste(
        "Until 2019, HELP loan repayments",
        "**started at 4%.** This meant anyone",
        "repaying a debt would see their",
        "balance go down.",
        sep = "<br>"
      ),
      size = 3
    ) +
    annotate_360_glasslight(
      x = 2023.5, y = 25000, hjust = 1,
      label = paste(
        "The **lower rates** introduced since",
        "then have meant people making small",
        "payments end up going backwards,",
        "as indexation overtakes their repayment.",
        sep = "<br>"
      ),
      size = 3
    ) +
    theme_360(base_size = 14) +
    theme(
      panel.ontop = TRUE,
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank(),
      panel.grid.major.y = element_line(colour = "#00000022"),
      panel.grid.minor.y = element_blank(),
    ) +
    labs(
      x = NULL, y = "HELP loan balance",
      fill = "Repayment rate",
      title = "HELP loan repayment rates",
      subtitle = paste(
        "The introduction of lower repayment rates in recent years has produced a new class of people",
        "whose **debt repayments are overshadowed by indexation**",
        sep = "<br>"),
      caption = paste(
        "**CHART:** James Goldie, 360info",
        "**DATA:** Australian Parliament House, Australian Taxation Office",
        sep = "<br>")) ->
repayment_rates_plot

save_360plot(repayment_rates_plot,
  here("out", "repayment-rates.png"), shape = "sdtv-landscape")
save_360plot(repayment_rates_plot,
  here("out", "repayment-rates.svg"), shape = "sdtv-landscape")

```