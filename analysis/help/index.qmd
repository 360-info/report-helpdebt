---
title: HELP loan analysis
subtitle: Interrogating HELP debts in the ATO individual sample files
format:
  360-analysis-html:
    # override for selected charts that do not expose individuals
    output: false
author: James Goldie
date: last-modified
code-fold: true
---

```{r}
#| label: setup
library(tidyverse)
library(here)
dir.create(here("out", "explore"), showWarnings = FALSE, recursive = TRUE)
```

# Unzipping the data

Data is delivered as a `.7z` file, `Sample files 2011-12 to 20??-20??.7z` (covering from 2011-12 onward).

:::{.callout-note}
The 1% sample files from 2003-04 to 2010-11 don't appear to have information on HELP debt, only an indicator showing _whether_ they have a debt.
:::

The file has individual, nested ZIP files for each financial year that have their own passwords.

:::{.callout-warning}
For now I'm going to manually unzip these password-protected ZIP files, so the following code will assume that the unprotected CSV files are available somewhere under `/data/raw` as `20??_sample_file.csv`.

**These files are not version controlled; you must apply for access to them from the [Australian Taxation Office](https://www.ato.gov.au/about-ato/research-and-statistics/in-detail/taxation-statistics/taxation-statistics-previous-editions/taxation-statistics-2017-18/statistics/individuals/individuals-sample-files).
:::

## Exploration

```{r}
#| label: load-data
tibble(
  path = list.files(
    here("data", "raw"),
    pattern = "20.._sample_file\\.(csv|txt)",
    recursive = TRUE,
    full.names = TRUE)) |>
  mutate(
    year_end = str_extract(basename(path), "20.."),
    data = map(path, read_csv,
      col_select = c(Taxable_Income, Help_debt))) ->
nested_2pc
```


```{r}
#| label: combine
nested_2pc |>
  pull(data) |>
  set_names(nested_2pc$year_end) |>
  bind_rows(.id = "year_end") |>
  select(year_end, income = Taxable_Income, help_debt = Help_debt) ->
unnested_2pc
```

Let's start exploring HELP debt and income with some histograms (well, frequency polygons):

```{r}
#| label: explore-histograms
#| output: true
# extend colour palette to > 9 years
pal_YlGnBu <- brewer.pal(7, "YlGnBu") |> colorRampPalette()
pal_YlOrRd <- brewer.pal(7, "YlOrRd") |> colorRampPalette()
year_count <- unnested_2pc |> pull(year_end) |> unique() |> length() 
help_balance_pal <- pal_YlGnBu(year_count)
income_pal <- pal_YlOrRd(year_count)

ggplot(unnested_2pc) +
  aes(x = help_debt) +
  geom_freqpoly(aes(colour = year_end)) +
  scale_x_continuous(
    transform = "log10",
    guide = guide_axis_logticks(),
    labels = scales::label_number(
      prefix = "$",
      scale_cut = scales::cut_short_scale())) +
  scale_colour_manual(values = help_balance_pal) +
  scale_y_continuous(
    labels = scales::label_number(scale_cut = scales::cut_short_scale())) +
  theme_minimal(base_size = 18) +
  theme(axis.ticks.length.x = rel(3)) +
  labs(
    x = "HELP debt balance",
    y = "Number of people",
    colour = "Financial\nyear end",
    title = "Distribution of HELP balances over time")

ggplot(unnested_2pc) +
  aes(x = income) +
  geom_freqpoly(aes(colour = year_end)) +
  scale_x_continuous(
    transform = "log10",
    guide = guide_axis_logticks(),
    labels = scales::label_number(
      prefix = "$",
      scale_cut = scales::cut_short_scale())) +
  scale_y_continuous(
    labels = scales::label_number(scale_cut = scales::cut_short_scale())) +
  scale_colour_manual(values = income_pal) +
  theme_minimal(base_size = 18) +
  theme(axis.ticks.length.x = rel(3)) +
  labs(
    x = "Taxable income",
    y = "Number of people",
    colour = "Financial\nyear end",
    title = "Distribution of taxable income over time")
```

How many people from each sample even have a debt?

```{r}
#| label: has-debt-percentage
#| output: true
unnested_2pc |>
  group_by(year_end, has_help_debt = help_debt > 0) |>
  summarise(n = n()) |>
  mutate(prop = n / sum(n, na.rm = TRUE)) |>
  filter(has_help_debt == TRUE)
```

And the mean income and balance each year (including those for whom it's zero)?

```{r}
#| label: mean-income-balance
#| output: true
unnested_2pc |>
  group_by(year_end) |>
  summarise(
    mean_income = mean(income, na.rm = TRUE),
    mean_help_bal = mean(help_debt, na.rm = TRUE)) |>
  ungroup()
```

### Estimating 2022, 2023 and 2024 using FY2001 taxpayers

Because we don't have sample files beyond 2021, I'm going to use that latest sample file for 2022, 2023 and 2024 to see the effect of indexation rate.

```{r}
#| label: estimate-2022-2024
replace_year <- function(df, year) {
  df |> filter(year_end == "2021") |> mutate(year_end = year)
}

unnested_2pc |>
  bind_rows(
    unnested_2pc |> replace_year("2022*"),
    unnested_2pc |> replace_year("2023*"),
    unnested_2pc |> replace_year("2024*")) ->
unnested_estimated  
```

### Calculating indexation and mandatory repayment

The Parliamentary Library [keeps a historical record](https://www.aph.gov.au/About_Parliament/Parliamentary_Departments/Parliamentary_Library/pubs/rp/rp2021/Chronologies/HigherEducation#_Toc67381554) of HELP loan repayment rates. The ATO has [more recent tables](https://www.ato.gov.au/tax-rates-and-codes/study-and-training-support-loans-rates-and-repayment-thresholds).

:::{.callout-note}
These tables are saved in `/data`. You may need to re-retrieve them if you're reproducing this analysis in later years.
:::

:::{.callout-warning}
For this analysis, I'm simply using taxable income as the measure for repayment. In reality, a few other items are considered:

- plus net rental losses (from 1996)
- plus total reportable fringe benefits amounts (from 1999)
- deduct exempt foreign employment income (from 2005)
- plus any total investment loss (which includes net rental losses) (from 2009)
- plus reportable super contributions (from 2009)
:::

Let's tidy up the repayment rate tables. Note that the top rate for each year is a _starting threshold_, so we'll change those to be infinite:

```{r}
#| label: get-repayment-rates
here("data", "repayment-rates-2004-2019.csv") |>
  read_csv(col_types = "ccc") |>
  pivot_longer(-Year, names_to = "rate", values_to = "threshold") |>
  mutate(
    year_end = paste0("20", str_sub(Year, 6, 7)),
    rate = if_else(rate == "Nil", "0", rate),
    rate = rate |>
      parse_number(locale = locale(grouping_mark = " ")) |>
      (\(x) x / 100)(),
    threshold = parse_number(threshold,
      locale = locale(grouping_mark = " "))) |>
  select(year_end, rate, threshold) |>
  filter(!is.na(threshold)) ->
repayment_rates_oldest

here("data", "repayment-rates-2019-2021.csv") |>
  read_csv(col_types = "ccc") |>
  pivot_longer(-Rate, names_to = "Year", values_to = "threshold") |>
  mutate(
    year_end = paste0("20", str_sub(Year, 6, 7)),
    rate = if_else(Rate == "Nil", "0", Rate),
    rate = rate |>
      parse_number(locale = locale(grouping_mark = " ")) |>
      (\(x) x / 100)(),
    threshold = parse_number(threshold,
      locale = locale(grouping_mark = " "))) |>
  select(year_end, rate, threshold) |>
  filter(!is.na(threshold)) ->
repayment_rates_older

# FY2022-2024
tidy_ratetables <- function(path) {
  year <- paste0(str_extract(basename(path), "20.."), "*")
  
  # read, turn thresholds into upper limits
  read_csv(path, col_types = "cc") |>
    mutate(
      year_end = year,
      threshold = `Repayment income (RI)` |>
        str_remove_all("\\$[\\d,]{1,9} â€“ ") |>
        str_replace_all(c(
          "Below " = "",
          " and above" = "")) |>
        parse_number(locale = locale(grouping_mark = " ")),
      # rate: nil => 0, drop %, / 100
      rate = if_else(`Repayment rate` == "Nil", "0", `Repayment rate`),
      rate = rate |>
        parse_number(locale = locale(grouping_mark = " ")) |>
        (\(x) x / 100)()) |>
    select(year_end, threshold, rate)
}

tibble(
  path = list.files(here("data"),
    pattern = glob2rx("repayment-rates-FY20??.csv"),
    full.names = TRUE)) |>
  mutate(data = map(path, tidy_ratetables)) |>
  unnest(data) |>
  select(-path) ->
repayment_rates_new
  

# combine the rates (set upper rates to inf)
repayment_rates_oldest |>
  bind_rows(repayment_rates_older) |>
  bind_rows(repayment_rates_new) |>
  rename(repay_rate = rate, repay_threshold = threshold) |>
  group_by(year_end) |>
  mutate(repay_threshold =
    if_else(repay_rate == max(repay_rate, na.rm = TRUE), Inf, repay_threshold)) ->
repayment_rates
```

Now we can apply them to our individual sample to work out repayment obligations based on people's incomes.

Since repayments are not progressive, we can use a rolling join to identify the relevant threshold and rate:

```{r}
#| label: calculate-repayments
unnested_estimated |>
  left_join(repayment_rates, join_by(
    year_end == year_end,
    closest(income <= repay_threshold))) |>
  mutate(repay_amount = help_debt * repay_rate) ->
unnested_repayments
```

Now let's handle indexation. This one is a fixed rate of taxable income each year. The ATO has [a table of historical indexation rates](https://www.ato.gov.au/tax-rates-and-codes/study-and-training-support-loans-indexation-rates) going back to 2013 (not ideal, but until 2011, the Higher Education Operations Grant index was used).


```{r}
#| label: indexation-rates
tribble(
  ~ year_end, ~ index_rate,
  "2024*",    "4.7%",
  "2023*",    "7.1%",
  "2022*",    "3.9%",
  "2021",     "0.6%",
  "2020",     "1.8%",
  "2019",     "1.8%",
  "2018",     "1.9%",
  "2017",     "1.5%",
  "2016",     "1.5%",
  "2015",     "2.1%",
  "2014",     "2.6%",
  "2013",     "2.0%") |>
  mutate(
    index_rate = index_rate |>
      parse_number(locale = locale(grouping_mark = " ")) |>
      (\(x) x / 100)()) ->
indexation_rates
```

Let's do another rolling join to the tax returns. Then, once we have both repayment amount and indexation amount, we'll work out net change and divide it by the balance to work out number of years to repay (obviously this assumes no future change to thresholds or income):

```{r}
#| label: calculate-indexation
unnested_repayments |>
  left_join(indexation_rates, join_by(year_end == year_end)) |>
  mutate(index_amount = help_debt * index_rate) |>
  filter(!is.na(index_rate)) |>
  # calc net change and repayment time
  mutate(
    net_reduction = repay_amount - index_amount,
    payback_yrs = help_debt / net_reduction) ->
unnested_payback
```

Let's try some visualisations to see this payback distribution. We'll need to remove the people with no debt:

```{r}
#| label: vis-payback
#| output: true
unnested_payback |>
  filter(help_debt > 0) |>
  mutate(
    repaying = payback_yrs > 0,
    payback_yrs_abs = abs(payback_yrs)) ->
finite_paybacks

# extend palette
pal_PuRd <- brewer.pal(7, "PuRd") |> colorRampPalette()
year_count_ext <- finite_paybacks |> pull(year_end) |> unique() |> length() 
payback_pal <- pal_PuRd(year_count_ext)

ggplot(finite_paybacks |> filter(year_end %in% c("2023*", "2024*"))) +
  aes(x = payback_yrs, colour = year_end) +
  geom_vline(xintercept = 0, colour = "#666666", linetype = "dotted") +
  geom_freqpoly(
    # bins = 100,
    position = "identity") +
  scale_x_continuous(
    limits = c(-40, 40)
    ) +
  scale_colour_manual(values = payback_pal) +
  theme_minimal(base_size = 12) +
  labs(
    x = "Payback time (years)\n(Positive: reducing debt)",
    y = "Number of people",
    colour = "Financial\nyear end",
    title = "Distribution of payback periods for HELP debt"
  )
```

I'm seeing some odd patterns in payback time for the latter years, so I'm going to run off some jittered points of reduction and payback period over time in the exploratory folder:

```{r}
#| label: jitter-changes
# warning - do not commit to version control (requires `output: true`)
ggplot(finite_paybacks) +
  aes(x = net_reduction, y = year_end) +
  geom_violin() +
  geom_point(position = "jitter", size = 0.25, alpha = 0.025) +
  geom_vline(xintercept = 0, colour = "red", linetype = "dotted") +
  labs(
    x = "Net reduction in debt",
    y = "Year") ->
netreduction_jitter

ggplot(finite_paybacks) +
  aes(x = payback_yrs, y = year_end) +
  geom_violin() +
  geom_point(position = "jitter", size = 0.25, alpha = 0.025) +
  geom_vline(xintercept = 0, colour = "red", linetype = "dotted") +
  scale_x_continuous(transform = scales::pseudo_log_trans(base = 10)) +
  labs(
    x = "Payback time in years",
    y = "Year") ->
payback_jitter

ggsave(
  here("out", "explore", "netreduction_jitter.png"),
  netreduction_jitter,
  width = 1920, height = 1080, units = "px", bg = "white")

ggsave(
  here("out", "explore", "payback_jitter.png"),
  payback_jitter,
  width = 1920, height = 1080, units = "px", bg = "white")

```

Lots of stuff to digest here. I'm curious why the behaviour of those with growing debts is very different in 2021 to in other years.

Let's look at this two dimensionally instead:

```{r}
#| label: heatmaps-plain
ggplot(finite_paybacks) +
  aes(x = income, y = help_debt) +
  geom_bin_2d() +
  facet_wrap(vars(year_end)) +
  scale_x_continuous(trans = "log10",
    labels = scales::label_number(
      prefix = "$",
      scale_cut = scales::cut_short_scale()),
    ) +
  scale_y_continuous(trans = "log10",
    labels = scales::label_number(
      prefix = "$",
      scale_cut = scales::cut_short_scale()),
    ) +
  scale_fill_binned(trans = "log10") +
  labs(
    x = "Taxable income",
    y = "HELP debt balance",
    title = "Heatmap of HELP balances")
```

Hard to see too much change over time in this view, to be honest; the heatmap is not as useful as I'd imagined.

:::{.callout-note}
2017 looks a bit different to the other years. The ATO does a kind of clamping on extreme values to protect individuals' privacy; I think they've just done that at $1 for 2017 instead of $100 (the other years).
:::

It might be more useful if we overlay payback periods on it, since indexation is an important component!

```{r}
#| label: points-payback
# warning - this plot shouldn't be rendered to version control
# (and won't be, unless you add `output: true`)! it shows individual points
ggplot(finite_paybacks) +
  aes(x = income, y = help_debt) +
  geom_point(aes(colour = net_reduction), alpha = 0.1, size = 0.5) +
  facet_wrap(vars(year_end)) +
  scale_x_continuous(trans = "log10", labels = scales::label_currency(),
    limits = c(10000, 1000000)) +
  scale_y_continuous(trans = "log10", labels = scales::label_currency(),
    limits = c(500, 500000)) +
  scale_colour_gradient2(
    limits = c(-5000, 5000),
    oob = scales::squish) +
  theme_dark(base_size = 8) +
  labs(
    x = "Taxable income",
    y = "HELP debt balance",
    colour = "Net reduction in debt",
    title = "Distribution of HELP balances") ->
heatmap_paybacks

ggsave(
  here("out", "explore", "income-balance-payback-points.png"),
  heatmap_paybacks,
  width = 1920, height = 1080, units = "px", bg = "white")
```

Finally, let's look at a heatmap of indexation and repayment:

```{r}
#| label: heatmap-indexation-repayment
ggplot(finite_paybacks) +
  aes(x = repay_amount, y = index_amount) +
  geom_bin_2d() +
  geom_abline(slope = 1, intercept = 0, colour = "#333333",
    linetype = "dotted") +
  annotate("text", label = "Reducing debt",
    x = Inf, y = -Inf, hjust = 1, vjust = 0
    ) +
  annotate("text", label = "Increasing\ndebt",
    x = -Inf, y = Inf,
    hjust = 0, vjust = 1
    ) +
  facet_wrap(vars(year_end)) +
  scale_x_continuous(
    # trans = "log10",
    labels = scales::label_number(
      prefix = "$",
      scale_cut = scales::cut_short_scale()),
    ) +
  scale_y_continuous(
    # trans = "log10",
    labels = scales::label_number(
      prefix = "$",
      scale_cut = scales::cut_short_scale()),
    ) +
  coord_fixed(2) +
  scale_fill_continuous(
    # trans = "log10"
    ) +
  labs(
    x = "Compulsory repayment",
    y = "Indexation",
    title = "Heatmap of HELP movement")
```

### Binning

This might be easier to digest if we bin net deduction and payback period up. We can put people into categories:

- No debt we'll remove altogether
- Debt went backwards (no repayment due to low income)
- Debt went backwards despite repayment (we could bin this up further)
- Debt basically went nowhere (indexation and repayment pretty balanced)
- Debt started going down (repayment exceeded indexation)

```{r}
#| label: binning
unnested_payback |>
  filter(help_debt > 0) |>
  mutate(
    help_category = case_when(
      repay_amount == 0 ~ "no_repayment",
      net_reduction < -200
    )
  )
```